---

layout: default

page_type: index

permalink: /

---

# Вводная {#intro}

Привет. На этой странице представлена концепция того, как <em>правильно</em> верстать в современном мире. «Старый добрый CSS» устарел, с появлением препроцессоров стали возможны вещи, которые с обычным CSS невозможны. Однако, чаще всего люди не стараются раскрыть потенциал препроцессора, используя только «шорткаты» к разным вещам, которые таки реализуемы и в обычном CSS.

Наш проект предполагает, что нужно выкинуть все имеющиеся навыки вёрстки — забыть про БЭМ, забыть про АНБ, забыть про многие аспекты вёрстки, и попробовать посмотреть на всё под другим углом.

Ниже можно увидеть криво-косо написанный текст про всё это дело, если хочется потрогать вершину айсберга руками — перейдите к странице «[блоки](blocks/)» — там можно увидеть черновую реализацию «островного» дизайна при помощи предлагаемой концепции. Если же хочется посмотреть на код, лежащий под этим делом, вот [внешний Гитхаб](https://github.com/yandex-ui/stylobate-islands/) реализации по ссылке выше, а вот [внешний Гитхаб](https://github.com/kizu/stylobate) с фреймворком, позволяющим всё это реализовать.

**Важно:** всё это дело находится в активной разработке, всё может поменяться, поломаться, исправиться. Снаружи Яндекса лучше пока не делиться ссылкой на фреймворк по этим причинам, ну и дабы не испортить первое впечатление.

**Ещё важнее:** скажите привет Опенсорсу — пишите замечания, сообщайте об ошибках, критикуйте подход и всё всё всё, присылайте пулл-реквесты! По фреймворку или конкретной реализации — issues в соответствующих проектах на Гитхабе, всё остальное можно писать мне на рабочую почту — kizu@.


## Абсолютная независимость {#independance}

### АНБ {#anb}

Широко известная концепция АНБ — Абсолютно Независимых Блоков — упирает на то, что любой блок должен стремиться быть независимым от окружения и стилей других независимых блоков. Однако, в АНБ упускается то, что подобный блок остаётся зависимым от одной сущности. Себя.

Это значит, что **стили блока** привязаны к конкретным **имени** и **HTML-стркутуре** блока.

Подобный CSS, состоящий из имён классов будь то `.button`, `.b-button` или `b-mail-button` сложно (а то и невозможно) применять на стороннем проекте. По сути, мы должны знать структуру HTML, к которой применяется необходимый CSS, мы должны гарантировать, что не будет пересечений в именах классов, а выбрав конкретную реализацию с конкретными именами классов мы не сможем просто переключиться на другую реализацию — нам придётся менять все классы или в HTML, или в CSS.

И, конечно, «скопипащенный» подобным образом код, с изменёнными именами классов, не получится поддерживать в свежем состоянии — каждый раз придётся или вручную накладывать диффы, или переиначивать все классы в новой версии исходной реализации.


### Препроцессоры {#preprocessors}

Но — у нас же есть препроцессоры.

Препроцессоры позволяют делать множество вещей, которые всё меняют. Миксины, функции, условия — всё это позволяет разнести места, где определяются конечные классы и структура кода, с непосредственной CSS-вёрсткой.

Чтобы описать нужный блок, можно написать вот так:

    .super-button
      kind: button
      skin: action-button fly small

Вместо того, чтобы прописывать все стили к этому классу напрямую.

Можно увидеть, что в коде используется только комбинация двух псевдо-CSS свойств: `kind` и `skin`, со всякими аргументами. Ниже на этой странице я объясню как это работает и почему оно работает именно так.

Если кратко, то наша таблица стилей подключает, во-первых, фреймворк Stylobate, во-вторых, реализованные с помощью этого фреймворка визуальные стили, лежащие миксинами в отдельном проекте. Подобное разделение, как уже упоминалось, позволяет обновлять стили в миксинах не затрагивая HTML-представление и конкретные классы. Можно подключить «портальный дизайн», реализованный подобным образом, на несколько разных проектах — с разными классами и подходами к вёрстке, и получить возможность обновлять всё одним `git pull` в сабмодуле реализации.

*To be continued…*
