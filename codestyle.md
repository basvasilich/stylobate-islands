---

layout: default

page_type: codestyle

---

# Code Style

## Основы

### Вайтспейсы

Во-первых, мы используем минималистичный стиль написания Стайлуса, из излишеств используем двоеточие между свойством и значением (с последующим пробелом):

>     .foo
>       width: 10px

Отступы — два пробела, никаких табов.

### Порядок свойств

Порядок свойств используем [_примерно_ такой](http://wiki.yandex-team.ru/verstka/CSS/StyleGuide#posledovatelnostsvojjstv), главное — группируем однотипные свойства.

### URL

Внутри `url()` используем двойные кавычки:

>     .foo
>       background: url("some-path-to-pic.png")

Это нужно для того, чтобы не пасть жертвой гибкого синтаксиса Стайлуса, который, если вы создадите переменную `png = "lol"`, подставит её значение в подобном случае (т.е. Стайлус содержимое урла без кавычек будет воспринимать как обычный аргумент, в котором могут использоваться переменные).

### Значения

1. Десятичные значения записываются с нулём в начале, например, `0.5em`

2. Цвета записываются как можно короче, апперкейсом:

    - `#FAFAFA`, а не `#fafafa`.
    - `#FFF`, а не `#FFFFFF`.

3. Везде, где можно, после запятой ставится пробел. Исключение: набор компонент цвета в `rgba` — `rgba(210,0,3, 0.4)`.

4. `rgba` желательно записывать в понимаемой Стайлусом нотации `rgba(#FFF, 0.5)` — это гораздо лучше читается и если используется сложный цвет, его будет проще «воссоздать» в графическом редакторе, скопировав hex-значение.


## Вложенность

Вложенность через амперсанд используем с опаской, только если это действительно нужно. Это обусловлено плохой читаемостью и поиском каскадных конструкций.

Пишем так:

>     .foo
>       width: 10px  
>     
>     .foo:hover
>       background: red
>     
>     .foo-bar
>       height: 10px

Исключения два:

1. Если вы делаете какой-то глобальный модификатор вроде `.page_minified`, то такой каскад нужно использовать чтобы случайно не применить свойства в общем скоупе, без модификатора.

2. Если вы планируете расширять (`@extends .foo`) соответствующую группу свойств, в этом случае из-за особенностей работы экстендов в Стайлусе придётся использовать вложенность.

При использовании вложенности амперсанд надо указывать __всегда__, примерно так:

>     .foo
>       color: blue
>
>       &:hover
>         color: red
>
>       &:active
>         background: lime


## Структурирование

Если в файле находится много всяких смысловых блоков, необходимо их группировать и снабжать описательными комментариями. При этом, друг от друга блоки отделяются двумя переносами строки для большей читаемости:

>     // Some block doing cool stuff
>     .foo
>       width: 10px
>     
>     .foo__element
>       height: 10px
>     
>     
>     // Another strange block
>     .strange-foo
>       position: sticky
>       right: 100px
>     
>     .strange-foo_dope
>       left: 10px

Во вложенных конструкциях (будь то условия Стайлуса, или вложенные блоки правил) необходимо по возможности класть их в конец блока правил, после стилей применяемых к исходному селектору, при этом их нужно отбивать пустой строкой:

>     .foo
>       color: red
>       background: lime
> 
>       if $whatever == true
>         display: none
>       else
>         display: block
> 
>       &:before
>         content: ''


## nib

Для разворачивания префсов используем nib, поэтому пишем CSS3-свойства без префиксов:

>     .fpp
>       border-radius: 10px
>       transition: transform 1s, width .4s linear

а Ниб уже сам развернёт всё, что нужно:

>    .foo {
>      -webkit-border-radius: 10px;
>      border-radius: 10px;
>      -webkit-transition: -webkit-transform 1s, width 0.4s linear;
>      -moz-transition: -moz-transform 1s, width 0.4s linear;
>      -o-transition: -o-transform 1s, width 0.4s linear;
>      -ms-transition: -ms-transform 1s, width 0.4s linear;
>      transition: transform 1s, width 0.4s linear;
>    }


## `if ie`

Мы используем отдельную таблицу стилей для ie, которую собираем, используя оригинальную таблицу стилей, пропущенную с установленной переменной Стайлуса `ie = true`. С помощью этого можно и нужно писать условия для ie прямо в основных таблицах стилей.

>     .foo
>       width: 10px
>       width: 12px if ie
>     
>     if ie
>       .foo-ololo
>         height: 12px

Таким образом можно как переопределять те или иные свойства (можно заметить, что при использовании в одном блоке правил достаточно использовать условие только во второй раз — для большинства свойств CSSO уберёт лишние стили сам), так и доопределять целые селекторы, используя условие блочно.

Кроме того, можно использовать отрицание `if !ie` — в таком случае можно будет задавать стили, которые **не попадут** в конечную таблицу стилей для ie. Это может быть полезно или для того, чтобы гарантированно не включать где-то неотключаемый hasLayout, или же просто для оптимизации: раз ie не поддерживает псевдоэлементы, то можно их обрамлять в условия так, что в таблице стилей для ie не будет этих, лишних для него, стилей:

>     .foo
>       width: 10px
>     
>     if !ie
>       .foo:before
>         content: 'ololo'

### [if-ie.styl](https://github.com/kizu/if-ie.styl)

В if-ie.styl есть гораздо больше всяких полезных вещей, рекомендуется изучить его ридми.

Скажем, свойство `zoom` можно не обрамлять в `if ie` — это делается автоматически, аналогично большинство CSS3-свойств в таблице стилей для IE не попадут.


## БЭМ-нотация

На данный момент в проекте используется следующая нотация:

1. Блок называется без префикса, например `foo`.
2. Элемент записывается через дефис, например `foo-bar`.
3. Модификатор записывается через одно подчёркивание, без описания типа модификатора (если это не критически необходимо), например `foo-bar_bazzy`.
4. В концепции рекомендуется использовать префиксное изменение блоков, а не постфиксное, так, лучше создать новый блок `small-button`, чем делать модификатор `button_small`

### Глобальные модификаторы

Для многих вещей лучше использовать глобальные модификаторы, например `is-disabled`, `is-current` и т.д.

Современные браузеры уже позволяют нормальног использовать такие модификаторы, при этом они обладают рядом достоинств (надо бы написать каких, хаха).

### Всё — блоки

По нотации видно, что практически нет разницы между блоками и элементами. Кроме того, вместо модификаторов рекомендуется использовать префиксное модифицирование блоков. Таким образом различные варианты блоков становятся независимее — как с точки зрения вёрстки, так и с точки зрения поведения. Наличие разных вариантов `.button`, `.small-button` и т.д. будет демотивировать использовать эти классы в JS (чего в любом случае не должно быть).

Правило простое: если модификатор не может поменяться во время работы интерфейса, то это префиксная нотация. Если же состояние блока может поменяться, но это часто встречающееся поведение (включение/выключение отображение, текущие пункты и т.д.), то лучше использовать глобальные модификаторы. В этих случаях БЭМ-модификаторы нужно будет использовать только если модификатор динамичный и гарантированно привязан к блоку.
